package {	import flash.display.Stage;	import flash.display.StageDisplayState;	import flash.display.StageScaleMode;		import flash.display.Sprite;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.geom.Point;		public class WarRoom extends Sprite {				public static const FULL_WIDTH  = 1280;		public static const FULL_HEIGHT = 960;		public static const HALF_WIDTH  = 640;		public static const HALF_HEIGHT = 480;		private const LOADING   = -1;		private const WAITING   = 0;		private const LOCKED    = 1;		private const LAUNCHING = 2;		private var state:int = -1;		private var map:MapGenerator;		private var prompt:Prompt;		private var rgb:RGBShift;		private var noise:Noise;		private var scanlines:Scanlines;		private var rollBar:RollBar;				public function WarRoom() {						map = new MapGenerator(2);			addChild(map);			map.addEventListener(MapEvent.ON_READY, startWar);			stage.displayState = StageDisplayState.FULL_SCREEN;			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.addEventListener(KeyboardEvent.KEY_UP, onBuzzerPress);		}		private function startWar(e:MapEvent):void {			map.removeEventListener(MapEvent.ON_READY, startWar);			map.addEventListener(MapEvent.ON_SHUFFLE, onMapShuffle);			addEffects();			goState(WAITING);		}		private function onMapShuffle(e:MapEvent):void {			var d:Point = e.newDestination;			trace("NEW DESTINATION: (" + d.x + "," + d.y + ")");		}		private function onBuzzerPress(e:KeyboardEvent):void {			trace("BUZZER PRESSED");			switch (state) {				case WAITING:					var target:Point = map.lockDownCurrentPosition();					showPrompt();					stage.focus = prompt.input;					goState(LOCKED);					break;				case LOCKED:					if (e.keyCode === Keyboard.ENTER) {						map.unlock();						removeChild(prompt);						goState(LAUNCHING);					}					// Listen for ESC key presses					if (e.keyCode === Keyboard.ESCAPE) {						map.unlock();						removeChild(prompt);						goState(WAITING);					}					break;				case LAUNCHING:					goState(WAITING);			}		}		private function addEffects() {			rgb = new RGBShift(this);			map.visible = false;			addChild(rgb);			noise = new Noise(FULL_WIDTH, FULL_HEIGHT);			addChild(noise);			//scanlines = new Scanlines(FULL_WIDTH, FULL_HEIGHT);			//addChild(scanlines);			rollBar = new RollBar(FULL_WIDTH, FULL_HEIGHT);			addChild(rollBar);		}		private function showPrompt(pW:int = 100, pH:int = 18):void {			trace("SHOWING PROMPT");			prompt = new Prompt(pW, pH, map.getBlockProperties());			//prompt.alpha = 0.8;			addChild(prompt);		}		public function goState(s:int):void {			state = s;			trace("=== State is now: " + state);		}	}	}