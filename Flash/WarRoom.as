package {	import flash.display.Stage;	import flash.display.StageDisplayState;	import flash.display.StageScaleMode;		import flash.display.Sprite;	import flash.display.Shape;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.geom.Point;	import retro.Scanlines;	import retro.RollBar;	import retro.Noise;	import retro.RGBShift;		// import map.Prompt;	// import map.MapEvent;	// import map.MapGenerator;	// import map.Prompt;		public class WarRoom extends Sprite {				public static const FULL_WIDTH  = 1280;		public static const FULL_HEIGHT = 960;		public static const HALF_WIDTH  = 640;		public static const HALF_HEIGHT = 480;		private const LOADING   = -1;		private const WAITING   = 0;		private const LOCKED    = 1;		private const LAUNCHING = 2;		private var state:int = -1;		private var map:MapGenerator;		private var prompt:Prompt;		private var rgbLayer:Sprite;		private var noise:Noise;		private var scanlines:Scanlines;		private var rollBar:RollBar;		private var connection:nodeConnection;				public function WarRoom() {						map = new MapGenerator(2);			addChild(map);			map.addEventListener(MapEvent.ON_READY, startWar);			stage.displayState = StageDisplayState.FULL_SCREEN;			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.addEventListener(KeyboardEvent.KEY_UP, onBuzzerPress);			connection = new nodeConnection();		}		private function startWar(e:MapEvent):void {			map.removeEventListener(MapEvent.ON_READY, startWar);			// addEffects();			map.addEventListener(MapEvent.ON_SHUFFLE, onMapShuffle);			goState(WAITING);		}		private function onMapShuffle(e:MapEvent):void {			var d:Point = e.newDestination;			trace("NEW DESTINATION: (" + d.x + "," + d.y + ")");			updateEffects();		}		private function onBuzzerPress(e:KeyboardEvent):void {			// trace(e.keyCode);			if (e.keyCode === 221) {				// trace("BUZZER PRESSED");				trace(map.getPoint());				drawLines(map.getPoint());			} else if (e.keyCode === 32) {				connection.sendBombardierDetails(j@lostwith.me, 1000, 0);			}			// switch (state) {			// 	case WAITING:			// 		var target:Point = map.lockDownCurrentPosition();			// 		showPrompt();			// 		stage.focus = prompt.input;			// 		goState(LOCKED);			// 		break;			// 	case LOCKED:			// 		if (e.keyCode === Keyboard.ENTER) {			// 			map.unlock();			// 			removeChild(prompt);			// 			goState(LAUNCHING);			// 		}			// 		// Listen for ESC key presses			// 		if (e.keyCode === Keyboard.ESCAPE) {			// 			map.unlock();			// 			removeChild(prompt);			// 			goState(WAITING);			// 		}			// 		break;			// 	case LAUNCHING:			// 		goState(WAITING);			// }		}		private function drawLines(point:Point) {			var hLine = new Shape();			hLine.graphics.beginFill(0xFFFFFF);			hLine.graphics.drawRect(0, point.y, FULL_WIDTH, 3);			hLine.graphics.endFill();			addChild(hLine);			var vLine = new Shape();			vLine.graphics.beginFill(0xFFFFFF);			vLine.graphics.drawRect(point.x, 0, 2, FULL_HEIGHT);			vLine.graphics.endFill();			addChild(vLine);		}		private function addEffects() {			rgbLayer = new Sprite();			addChild(rgbLayer);			rgbLayer.addChild(new RGBShift(this));			map.visible = false;			noise = new Noise(FULL_WIDTH, FULL_HEIGHT);			addChild(noise);			//scanlines = new Scanlines(FULL_WIDTH, FULL_HEIGHT);			//addChild(scanlines);			rollBar = new RollBar(FULL_WIDTH, FULL_HEIGHT);			addChild(rollBar);		}		private function updateEffects():void {			rgbLayer.removeChildAt(0);			map.visible = true;			noise.visible = true;			rollBar.visible = false;			rgbLayer.addChild(new RGBShift(this));			map.visible = false;			noise.visible = true;			rollBar.visible = true;		}		private function showPrompt(pW:int = 100, pH:int = 18):void {			trace("SHOWING PROMPT");			prompt = new Prompt(pW, pH, map.getBlockProperties());			//prompt.alpha = 0.8;			addChild(prompt);		}		public function goState(s:int):void {			state = s;			trace("=== State is now: " + state);		}	}	}