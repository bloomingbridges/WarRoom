package {	import flash.system.Security;	import flash.display.Stage;	import flash.display.StageDisplayState;	import flash.display.StageScaleMode;		import flash.display.Sprite;	import flash.display.Shape;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.ui.Keyboard;	import flash.geom.Point;	import retro.Gridlines;	import retro.RollBar;	import retro.Noise;	import retro.RGBShift;	import node.NodeConnection;	import flash.system.fscommand;		// import map.Arc;	// import map.MapEvent;	// import map.MapGenerator;	// import map.Prompt;		public class WarRoom extends Sprite {				public static const bW = 2;		public static const bH = 3;		public static const bS = 2;		public static const FULL_WIDTH  = (bW + bS) * 360;		public static const FULL_HEIGHT = (bH + bS) * 143;		public static const HALF_WIDTH  = 640;		public static const HALF_HEIGHT = 480;		private const LOADING   = -1;		private const WAITING   = 0;		private const LOCKING   = 1;		private const LOCKED    = 2;		private const LAUNCHING = 3;		private const MISSILE_SPEED = 4.7;		private var state:int = -1;		private var currentTarget:Point;		private var map:MapGenerator;		private var prompt:Prompt;		private var rgbLayer:Sprite;		private var noise:Noise;		private var gridlines:Gridlines;		private var container:Sprite;		private var rollBar:RollBar;			private var connection:NodeConnection;				public function WarRoom() {			Security.loadPolicyFile("http://localhost:8888/crossdomain.xml");						map = new MapGenerator();			addChild(map);			map.addEventListener(MapEvent.ON_READY, startWar);			container = new Sprite();			addChild(container);			gridlines = new Gridlines();			addChild(gridlines);			fscommand("trapallkeys", "true");			stage.showDefaultContextMenu = false;			stage.displayState = StageDisplayState.FULL_SCREEN;			// stage.scaleMode = StageScaleMode.NO_SCALE;			stage.scaleMode = StageScaleMode.SHOW_ALL;			stage.addEventListener(KeyboardEvent.KEY_UP, onKeyPress);			stage.addEventListener(MouseEvent.CLICK, onBuzzer);			connection = new NodeConnection();			// var arcs = [];			// for (var i = 0; i < 5; i++) {			// 	var x:int = Math.floor( Math.random() * 360 );			// 	var y:int = Math.floor( Math.random() * 143 );			// 	arcs[i] = new Arc(new Point(x, y));			// 	container.addChild(arcs[i]);			// }		}		private function startWar(e:MapEvent):void {			map.removeEventListener(MapEvent.ON_READY, startWar);			// addEffects();			map.addEventListener(MapEvent.ON_SHUFFLE, onMapShuffle);			goState(WAITING);		}		private function onMapShuffle(e:MapEvent):void {			var d:Point = e.newDestination;			trace("NEW DESTINATION: (" + d.x + "," + d.y + ")");			// updateEffects();		}		private function onKeyPress(e:KeyboardEvent):void {			//trace(e.keyCode);			//trace(stage.focus);			/*if (e.keyCode === Keyboard.F6) {				trace("BUZZER PRESSED");				drawLines(map.getPoint());				goState(LOCKING);			} else if (e.keyCode === Keyboard.F6) {				var time:int = calculateTimeOfArrival(7,0);				connection.sendBombardierDetails("brueckner.florian@googlemail.com", 1000, time);			} else if (e.keyCode === 219) {				//launchMissile();			} */			switch (state) {				case WAITING:					trace("WAITING FOR BUZZER PRESS");					break;				case LOCKING:					currentTarget = map.pickNewDestination();					showPrompt();					stage.focus = prompt.input;					stage.addEventListener(KeyboardEvent.KEY_UP, prompt.doBackspace);					goState(LOCKED);					break;				case LOCKED:					if (e.keyCode === Keyboard.ENTER) {						var t:int = calculateTimeOfArrival(7,0);						trace(currentTarget);						launchMissileAt(currentTarget);						connection.sendBombardierDetails(prompt.input.text, map.getPopulation(), t)						map.unlock();						stage.removeEventListener(KeyboardEvent.KEY_UP, prompt.doBackspace);						removeChild(prompt);						prompt = null;						container.removeChildAt(0);						container.removeChildAt(0);						goState(LAUNCHING);					}					break;				case LAUNCHING:					goState(WAITING);					stage.focus = null;					break;			}		}		private function onBuzzer(e:MouseEvent) {			trace("BUZZER PRESSED");			if (prompt == null) {				trace(stage.focus);				currentTarget = map.pickNewDestination();				drawLines(currentTarget);				showPrompt();				stage.focus = prompt.input;				stage.addEventListener(KeyboardEvent.KEY_UP, prompt.doBackspace);				goState(LOCKED);			}			else {				stage.focus = prompt.input;			}		}		private function drawLines(point:Point) {			var hLine = new Shape();			hLine.graphics.beginFill(0xFFFFFF);			hLine.graphics.drawRect(0, point.y, FULL_WIDTH, 3);			hLine.graphics.endFill();			container.addChild(hLine);			var vLine = new Shape();			vLine.graphics.beginFill(0xFFFFFF);			vLine.graphics.drawRect(point.x, 0, 2, FULL_HEIGHT);			vLine.graphics.endFill();			container.addChild(vLine);		}		private function launchMissile() {			// var arcs = [];			// for (var i = 0; i < 360; i++) {			// 	arcs[i] = new Arc(new Point(360,143));			// 	// arcs[i] = new Arc(map.pickNewDestination());			// 	container.addChild(arcs[i]);			// }			//var arc = new Arc(map.pickNewDestination());			//addChild(arc);		}		private function launchMissileAt(coordinates:Point) {			var dX = Math.abs(175-coordinates.x);			var dY = Math.abs(37-coordinates.y);			trace("DISTANCE", dX, dY, coordinates);			var arc = new Arc(coordinates, calculateTimeOfArrival(dX,dY));			addChild(arc);		}		private function addEffects() {			// rgbLayer = new Sprite();			// addChild(rgbLayer);			// rgbLayer.addChild(new RGBShift(this));			// map.visible = false;			// gridlines.visible = false;			noise = new Noise(FULL_WIDTH, FULL_HEIGHT);			addChild(noise);			rollBar = new RollBar(FULL_WIDTH, FULL_HEIGHT);			addChild(rollBar);		}		private function updateEffects():void {			rgbLayer.removeChildAt(0);			map.visible = true;			noise.visible = true;			rollBar.visible = false;			rgbLayer.addChild(new RGBShift(this));			map.visible = false;			noise.visible = true;			rollBar.visible = true;		}		private function showPrompt(pW:int = 100, pH:int = 18):void {			trace("SHOWING PROMPT");			prompt = new Prompt(pW, pH, map.getBlockProperties());			//prompt.alpha = 0.8;			addChild(prompt);		}		private function calculateTimeOfArrival(distanceX:int, distanceY:int):int {			var now:Date = new Date();			var s:int = Math.sqrt(Math.pow(distanceX,2)+Math.pow(distanceY,2));			s *= 111;			return (s / MISSILE_SPEED) * 1000;		}		public function goState(s:int):void {			state = s;			trace("=== State is now: " + state);		}	}	}